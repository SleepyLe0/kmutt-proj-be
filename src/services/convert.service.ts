import MainService from './main.service';
import { HttpException } from '@/exceptions/HttpException';
import * as path from 'path';
import * as fs from 'fs';
import { exec } from 'child_process';
import { promisify } from 'util';
import * as os from 'os';

const execAsync = promisify(exec);

// LibreOffice path configuration
const getLibreOfficePath = (): string => {
  if (process.platform === 'win32') {
    const possiblePaths = [
      'C:\\Program Files\\LibreOffice\\program\\soffice.exe',
      'C:\\Program Files (x86)\\LibreOffice\\program\\soffice.exe',
    ];
    for (const p of possiblePaths) {
      if (fs.existsSync(p)) {
        return `"${p}"`;
      }
    }
    return 'soffice'; // Fallback to PATH
  } else if (process.platform === 'darwin') {
    return '/Applications/LibreOffice.app/Contents/MacOS/soffice';
  } else {
    return 'soffice'; // Linux
  }
};

interface ConvertResult {
  filename: string;
  pdfBuffer: string;
  size: number;
  originalFilename: string;
}

class ConvertService extends MainService {
  public async excelToPdf(
    fileBuffer: Buffer,
    originalFilename: string
  ): Promise<ConvertResult> {
    let tempInputPath: string | null = null;
    let tempOutputDir: string | null = null;

    try {
      // Validate file extension
      const fileExtension = originalFilename.split('.').pop()?.toLowerCase();
      if (!fileExtension || !['xlsx', 'xls'].includes(fileExtension)) {
        throw new HttpException(
          400,
          'Invalid file type. Only .xlsx and .xls files are supported'
        );
      }

      // Validate buffer
      if (!fileBuffer || fileBuffer.length === 0) {
        throw new HttpException(400, 'File buffer is empty');
      }

      // Create temp directory for conversion
      tempOutputDir = fs.mkdtempSync(path.join(os.tmpdir(), 'excel-pdf-'));
      tempInputPath = path.join(tempOutputDir, originalFilename);

      // Write buffer to temp file
      fs.writeFileSync(tempInputPath, fileBuffer);

      // Get LibreOffice path
      const sofficePath = getLibreOfficePath();

      // Convert using LibreOffice command line
      // --headless: run without GUI
      // --convert-to pdf: convert to PDF format
      // --outdir: output directory
      const command = `${sofficePath} --headless --convert-to pdf --outdir "${tempOutputDir}" "${tempInputPath}"`;

      const { stdout, stderr } = await execAsync(command, {
        timeout: 60000, // 60 second timeout
      });

      // Find the generated PDF file
      const baseFilename = originalFilename.replace(/\.[^/.]+$/, '');
      const pdfFilename = `${baseFilename}.pdf`;
      const pdfPath = path.join(tempOutputDir, pdfFilename);

      // Check if PDF was created
      if (!fs.existsSync(pdfPath)) {
        throw new Error('PDF file was not generated by LibreOffice');
      }

      // Read the PDF file
      const pdfBuffer = fs.readFileSync(pdfPath);

      // Convert buffer to base64 for response
      const base64Pdf = pdfBuffer.toString('base64');

      return {
        filename: pdfFilename,
        pdfBuffer: base64Pdf,
        size: pdfBuffer.length,
        originalFilename: originalFilename,
      };
    } catch (error) {
      console.error('Error converting Excel to PDF:', error);
      if (error instanceof HttpException) {
        throw error;
      }
      throw new HttpException(
        500,
        `Failed to convert Excel file to PDF: ${error.message || 'Unknown error'}`
      );
    } finally {
      // Cleanup temp files
      try {
        if (tempInputPath && fs.existsSync(tempInputPath)) {
          fs.unlinkSync(tempInputPath);
        }
        if (tempOutputDir && fs.existsSync(tempOutputDir)) {
          // Delete all files in temp directory
          const files = fs.readdirSync(tempOutputDir);
          for (const file of files) {
            fs.unlinkSync(path.join(tempOutputDir, file));
          }
          fs.rmdirSync(tempOutputDir);
        }
      } catch (cleanupError) {
        console.error('Error cleaning up temp files:', cleanupError);
      }
    }
  }
}

export default ConvertService;
